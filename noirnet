#!/usr/bin/env bash
# App Name: NoirNet
# Description: Monitors to see if the device has internet and DNS access and send notifications.
# Author: John Smith III
# License: MIT License

# App version and name
readonly APP_NAME="NoirNet"
readonly VERSION=1.4.1
readonly LAST_UPDATED="2024-12-30"

# TODO:
#  - Add more notification methods (email, slack, discord, etc.)

# ==============================
# Application Specific Variables
# ==============================

# CSV downtime history files
NETWORK_CSV_FILE="network_downtime.csv"
DNS_CSV_FILE="dns_downtime.csv"

# Default Google DNS
PING_TARGET="8.8.8.8"

# Default test domain
DNS_TEST_DOMAIN="example.com"

# Application specific dependencies
DEPENDENCIES=("nslookup" "ping")

# ==============================
# Base Application Variables
# ==============================

# Default configuration file location (full default path added during initialization)
CONFIG_FILE_NAME="$(basename "$0").json"
SKIP_CONFIG_KEYS=("PID_FILE")

# Master directory to store all cache files (full default path added during initialization)
CACHE_DIR="$(basename "$0")_cache"

# Default log file location (full default path added during initialization)
LOG_FILE_NAME="$(basename "$0").log"
INIT_FORCE=false

# Lock file (full default path added during initialization)
PID_FILE_NAME="$(basename "$0").pid"

# Service mode flag
IS_SERVICE=false

# Default check interval (in seconds)
CHECK_INTERVAL="60s"

# Default timeout interval (in seconds)
TIMEOUT="5s"

# Default check repeat (0=infinite)
REPEAT=0

# Pushover notification options
PUSHOVER_NOTIFICATION=false
PUSHOVER_USER_KEY=
PUSHOVER_API_TOKEN=

# Native desktop notification options
DESKTOP_NOTIFICATION=false

# Log levels
# Define log levels directly as an associative array
readonly declare -A LOG_LEVELS_MAP=(
    ["FATAL"]=0
    ["ERROR"]=1
    ["WARN"]=2
    ["INFO"]=3
    ["DEBUG"]=4
)
LOG_LEVEL="INFO"
VERBOSE=false

# System host name
SYSTEM_NAME=""

# ANSI color codes
readonly RED='\033[0;31m'
readonly RED_BG='\033[41m'
readonly GREEN='\033[0;32m'
readonly GREEN_BG='\033[42m'
readonly YELLOW='\033[1;33m'
readonly YELLOW_BG='\033[43m'
readonly ORANGE='\033[0;33m'
readonly ORANGE_BG='\033[43m'
readonly NC='\033[0m' # No Color

# ==============================
# Utility Functions
# ==============================

# Function: Show version information
show_version() {
    printf "%s version: %s\n" "$APP_NAME" "$VERSION"
    printf "Last updated: %s\n" "$LAST_UPDATED"
}

# Function: Check for required command-line utilities
check_dependencies() {
    DEPENDENCIES+=("cat" "curl" "hostname" "jq" "sed")

    case "$OSTYPE" in
    linux*)
        DEPENDENCIES+=("realpath")
        ;;
    darwin*)
        DEPENDENCIES+=("grealpath")
        ;;
    cygwin* | msys* | win32*)
        DEPENDENCIES+=("powershell")
        ;;
    *)
        log_message "FATAL" "Unsupported OS: $OSTYPE" "$LINENO"
        exit 1
        ;;
    esac

    for cmd in "${DEPENDENCIES[@]}"; do
        # Debug log for each dependency being checked
        log_message "DEBUG" "Checking if dependency '$cmd' is installed..." "$LINENO"

        if ! command -v "$cmd" &>/dev/null; then
            log_message "FATAL" "Error: $cmd is not installed. Please install it and try again." "$LINENO"
            exit 1
        else
            log_message "DEBUG" "Success: $cmd is installed!" "$LINENO"
        fi
    done

    # Optional success debug log
    log_message "DEBUG" "All dependencies are installed." "$LINENO"
}

# Function: Get system host name
get_hostname() {
    case "$OSTYPE" in
    linux* | darwin*)
        hostname
        ;;
    cygwin* | msys* | win32*)
        powershell -NoProfile -Command "[System.Net.Dns]::GetHostName()"
        ;;
    *)
        log_message "FATAL" "Unsupported OS: $OSTYPE" "$LINENO"
        exit 1
        ;;
    esac
}

# Function: Normalize paths
normalize_path() {
    local path="$1"
    local normalized_path

    case "$OSTYPE" in
    linux*)
        if command -v realpath >/dev/null 2>&1; then
            # Use `realpath -m` for non-existent paths on Linux
            normalized_path=$(realpath -m "$path" 2>/dev/null || echo "$(realpath -m "$(dirname "$path")")/$(basename "$path")")
        else
            echo "realpath not found on Linux" >&2
            exit 1
        fi
        ;;
    darwin*)
        if command -v grealpath >/dev/null 2>&1; then
            # Use `grealpath -m` for non-existent paths on macOS
            normalized_path=$(grealpath -m "$path" 2>/dev/null || echo "$(grealpath -m "$(dirname "$path")")/$(basename "$path")")
        else
            echo "grealpath not found on macOS. Install it using 'brew install coreutils'" >&2
            exit 1
        fi
        ;;
    cygwin* | msys* | win32*)
        # Use PowerShell to resolve the path on Windows
        normalized_path=$(powershell -NoProfile -Command "try { (Resolve-Path -LiteralPath '$path').Path } catch { [System.IO.Path]::GetFullPath('$path') }")
        ;;
    *)
        echo "Unsupported OS: $OSTYPE" >&2
        exit 1
        ;;
    esac

    echo "$normalized_path"
}

# Function: Normalize filenames
normalize_filename() {
    local filename="$1"
    filename=$(echo "$filename" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | tr -d '\\/:*?"<>|')
    echo "$filename"
}

# Function: Get the root configuration directory and set the config file path
get_config_path() {
    local append_path="$1"
    local config_dir

    case "$OSTYPE" in
    linux* | darwin*)
        config_dir="$HOME/.config"
        ;;
    cygwin* | msys* | win32*)
        config_dir="$APPDATA\\"
        ;;
    *)
        log_message "FATAL" "Unsupported OS: $OSTYPE" "$LINENO"
        exit 1
        ;;
    esac

    local full_path="$config_dir/$append_path"
    echo "$(normalize_path "$full_path")"
}

# Function: Get the temporary directory path
get_temp_path() {
    local append_path="$1"
    local temp_dir

    case "$OSTYPE" in
    linux* | darwin*)
        temp_dir="/tmp"
        ;;
    cygwin* | msys* | win32*)
        temp_dir="$TEMP"
        ;;
    *)
        log_message "FATAL" "Unsupported OS: $OSTYPE" "$LINENO"
        exit 1
        ;;
    esac

    local full_path="$temp_dir/$append_path"
    echo "$(normalize_path "$full_path")"
}

# Function: Edit a specified file
edit_file() {
    local file="$1"

    if [[ -z "$file" ]]; then
        log_message "FATAL" "No file specified to edit." "$LINENO"
        exit 1
    fi

    if [[ ! -f "$file" ]]; then
        log_message "FATAL" "File not found: $file" "$LINENO"
        exit 1
    fi

    if [[ -n "$EDITOR" ]]; then
        if command -v "$EDITOR" &>/dev/null; then
            "$EDITOR" "$file"
            exit 0
        else
            log_message "FATAL" "Specified editor '$EDITOR' is not available." "$LINENO"
            exit 1
        fi
    fi

    case "$OSTYPE" in
    darwin*)
        open "$file"
        ;;
    linux*)
        xdg-open "$file"
        ;;
    cygwin* | msys* | win32*)
        start "" "$file"
        ;;
    *)
        log_message "FATAL" "Unsupported OS: $OSTYPE" "$LINENO"
        exit 1
        ;;
    esac

    exit 0
}

# Function: Convert a frequency/interval string to seconds
get_interval_in_seconds() {
    local input_frequency="$1" # Input frequency/interval string
    local interval             # Variable to store the converted interval in seconds

    # Check if the input is a number without any unit
    if [[ "$input_frequency" =~ ^[0-9]+$ ]]; then
        interval=$input_frequency # Default to seconds if no unit is specified
    else
        # Determine the unit and convert accordingly
        case "${input_frequency: -1}" in
        s) interval=${input_frequency%?} ;;              # Seconds
        m) interval=$((${input_frequency%?} * 60)) ;;    # Minutes to seconds
        h) interval=$((${input_frequency%?} * 3600)) ;;  # Hours to seconds
        d) interval=$((${input_frequency%?} * 86400)) ;; # Days to seconds
        *)
            echo "Invalid frequency format"
            return 1
            ;; # Handle invalid formats
        esac
    fi

    echo "$interval" # Return the interval in seconds
}

# Function: Convert date to human-readable format
convert_date() {
    local date_str="$1"
    local human_readable_date

    if [[ "$OSTYPE" == "linux"* ]]; then
        human_readable_date=$(date -d "$date_str" +"%Y-%m-%d %H:%M:%S %Z")
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        human_readable_date=$(date -j -f "%Y-%m-%dT%H:%M:%SZ" "$date_str" +"%Y-%m-%d %H:%M:%S %Z")
    elif [[ "$OSTYPE" == "cygwin" || "$OSTYPE" == "msys" || "$OSTYPE" == "win32" ]]; then
        human_readable_date=$(date -d "$date_str" +"%Y-%m-%d %H:%M:%S %Z")
    else
        human_readable_date="$date_str"
    fi

    echo "$human_readable_date"
}

# ==============================
# Logging and Messaging Functions
# ==============================

# Function: Check if the current log level is at or above a given level
log_at_or_above() {
    local level_name=$1

    # Get indices from the associative array
    local current_level_index=${LOG_LEVELS_MAP[$LOG_LEVEL]}
    local check_level_index=${LOG_LEVELS_MAP[$level_name]}

    # Compare indices
    if [[ $current_level_index -ge $check_level_index ]]; then
        return 0 # true: log level is at or above the given level
    else
        return 1 # false: log level is below the given level
    fi
}

# Function: Log messages to console
log_to_console() {
    local log_level_name=$1
    local message=$2
    local line_number=$3
    # Generate an ISO 8601 timestamp in UTC
    local timestamp=$(date -u "+%Y-%m-%dT%H:%M:%SZ")
    local output_message="$message"

    # If verbose mode or debug level is enabled, format the output with timestamp and log level
    if [[ "$VERBOSE" = true || "$LOG_LEVEL" = "DEBUG" ]]; then
        output_message="$timestamp [$log_level_name] $message (Line: $line_number)"
    fi

    # Escape special characters to avoid issues with printf
    local safe_message=$(printf "%s" "$output_message" | sed 's/[^[:print:]\t]//g') # Remove non-printable characters

    # Handle different log levels
    case $log_level_name in
    "FATAL")
        printf "${RED_BG}%b${NC}\n" "$safe_message" >&2
        ;;
    "ERROR")
        printf "${RED}%b${NC}\n" "$safe_message" >&2
        ;;
    "WARN")
        printf "${YELLOW}%b${NC}\n" "$safe_message" >&2
        ;;
    *)
        printf "%b${NC}\n" "$safe_message" >&2
        ;;
    esac
}

# Function: Log messages
log_message() {
    local log_level_name=$1
    local message=$2
    local line_number=${3:-"N/A"}
    local timestamp=$(date -u "+%Y-%m-%dT%H:%M:%SZ")

    # Validate log level name
    local log_level_index=${LOG_LEVELS_MAP[$log_level_name]}
    if [[ -z "$log_level_index" ]]; then
        log_level_name="INFO"
        log_level_index=${LOG_LEVELS_MAP[$log_level_name]}
        printf "%s\n" "$timestamp [ERROR] Invalid log level specified. Defaulting to INFO." >&2
    fi

    # Validate current log level
    local current_log_level_index=${LOG_LEVELS_MAP[$LOG_LEVEL]}
    if [[ -z "$current_log_level_index" ]]; then
        printf "%s\n" "$timestamp [ERROR] Invalid global log level. Defaulting to INFO." >&2
        LOG_LEVEL="INFO"
        current_log_level_index=${LOG_LEVELS_MAP[$LOG_LEVEL]}
    fi

    # Format the log message
    local formatted_message="$timestamp [$log_level_name] $message"
    if [[ "$VERBOSE" = true || "$LOG_LEVEL" = "DEBUG" ]]; then
        formatted_message="$formatted_message (Line: $line_number)"
    fi

    # Escape special characters in the message to prevent breaking formatting
    local safe_message=$(printf "%s" "$formatted_message" | sed 's/[^[:print:]\t]//g')

    # Log to file if the log level meets the criteria and the log file exists
    if log_at_or_above "$log_level_name" && [[ -f "$LOG_FILE" ]]; then
        printf "%s\n" "$safe_message" >>"$LOG_FILE" 2>/dev/null || true
    fi

    # Always log to the console if not running as a service, or if no log file exists
    if [[ "$IS_SERVICE" != true || ! -f "$LOG_FILE" ]] && log_at_or_above "$log_level_name"; then
        log_to_console "$log_level_name" "$message" "$line_number"
    fi
}

# Function: Initialize the log file
init_log() {
    # Ensure the directory for the log file exists
    log_dir=$(dirname "$LOG_FILE")
    if [ ! -d "$log_dir" ]; then
        printf "Log file directory %s does not exist. Creating it...\n" "$log_dir"
        mkdir -p "$log_dir" || {
            log_message "FATAL" "Failed to create directory: $log_dir" "$LINENO"
            exit 1
        }
    fi

    if [ -z "$LOG_FILE" ]; then
        log_message "FATAL" "LOG_FILE variable is not set." "$LINENO"
        exit 1
    fi

    if [ ! -f "$LOG_FILE" ]; then
        # Attempt to create the log file
        if touch "$LOG_FILE" 2>/dev/null; then
            log_message "DEBUG" "Created log file: $LOG_FILE" "$LINENO"
        else
            log_message "FATAL" "Failed to create log file: $LOG_FILE" "$LINENO"
            exit 1
        fi
    else
        # Check if the log file is writable
        if [ ! -w "$LOG_FILE" ]; then
            log_message "FATAL" "Log file exists but is not writable: $LOG_FILE" "$LINENO"
            exit 1
        fi
        log_message "DEBUG" "Log file already exists and is writable: $LOG_FILE" "$LINENO"
    fi
}

# Function: Log the log file to the screen
show_log() {
    if [ -f "$LOG_FILE" ]; then
        cat "$LOG_FILE"
    else
        log_message "INFO" "Log file not found: $LOG_FILE" "$LINENO"
    fi
    exit 0
}

# ==============================
# Cache Management Functions
# ==============================

# Function: Check if a directory is a mount point
is_mount_point() {
    local dir="$1"

    if [[ "$OSTYPE" == "linux"* ]]; then
        # Use `findmnt` if available on Linux
        if command -v findmnt >/dev/null 2>&1; then
            findmnt -n -o TARGET --target "$dir" >/dev/null 2>&1
            return $?
        fi
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        # macOS: Use `df` to check if the directory is a separate mount
        if [[ $(df "$dir" 2>/dev/null | tail -n +2 | awk '{print $NF}') == "$dir" ]]; then
            return 0
        fi
    elif [[ "$OSTYPE" == "msys" || "$OSTYPE" == "cygwin" ]]; then
        # Windows: Skip mount point check as it's less relevant for typical use cases
        return 1
    fi

    # Default: Assume it's not a mount point
    return 1
}

# Function: Check if a directory is critical
is_critical_directory() {
    local dir="$1"
    local critical_dirs=(
        "/" "/home" "/bin" "/boot" "/dev" "/etc" "/lib" "/lib64" "/proc" "/root" "/sbin" "/sys" "/usr" "/var" "/tmp"
        "C:\\" "C:\\Windows" "C:\\Program Files" "C:\\Program Files (x86)" "C:\\Users" "C:\\Documents and Settings"
    )

    # Check if the directory is in the list of critical directories
    for critical_dir in "${critical_dirs[@]}"; do
        if [[ "$dir" == "$critical_dir" ]]; then
            return 0 # true: critical directory
        fi
    done

    # Protect symbolic links
    if [[ -L "$dir" ]]; then
        return 0 # true: critical directory
    fi

    # Check if the directory is a mount point (cross-platform)
    if is_mount_point "$dir"; then
        return 0 # true: critical directory
    fi

    return 1 # false: not a critical directory
}

# Function: Delete all cached files
delete_cache() {
    log_message "INFO" "Deleting all cached files..." "$LINENO"

    # Ensure CACHE_DIR is defined and not empty
    if [[ -z "$CACHE_DIR" ]]; then
        log_message "FATAL" "CACHE_DIR is not set. Unable to proceed." "$LINENO"
        exit 1
    fi

    # Ensure CACHE_DIR exists
    if [[ ! -d "$CACHE_DIR" ]]; then
        log_message "FATAL" "Cache directory '$CACHE_DIR' does not exist." "$LINENO"
        exit 1
    fi

    # Prevent deletion of critical directories
    if is_critical_directory "$CACHE_DIR"; then
        log_message "FATAL" "Attempted to delete a critical directory '$CACHE_DIR'. Aborting." "$LINENO"
        exit 1
    fi

    # Attempt to delete the cache directory
    if rm -rf "$CACHE_DIR"; then
        log_message "INFO" "Success: All cached files in '$CACHE_DIR' deleted." "$LINENO"
        exit 0
    else
        log_message "FATAL" "Failed to delete cached files in '$CACHE_DIR'." "$LINENO"
        exit 1
    fi
}

# Function: Initialize the cache directory
init_cache() {
    # Create the master cache directory and log file if they don't exist
    if [ ! -d "$CACHE_DIR" ]; then
        mkdir -p "$CACHE_DIR"
        log_message "DEBUG" "Created cache directory: $CACHE_DIR" "$LINENO"
    else
        log_message "DEBUG" "Cache directory already exists: $CACHE_DIR" "$LINENO"
    fi
}

# ==============================
# Notification Functions
# ==============================

# Function: Send desktop notifications
send_desktop_notification() {
    local title="$1"
    local message="$2"

    if [ "$DESKTOP_NOTIFICATION" = true ]; then
        if [[ "$OSTYPE" == "darwin"* ]]; then
            if ! osascript -e "display notification \"$message\" with title \"$title\""; then
                log_message "ERROR" "Failed to send notification on macOS." "$LINENO"
            fi
        elif [[ "$OSTYPE" == "linux"* ]]; then
            if command -v notify-send &>/dev/null; then
                notify-send "$title" "$message"
            else
                log_message "ERROR" "notify-send is not installed. Install it to enable notifications on Linux." "$LINENO"
            fi
        elif [[ "$OSTYPE" == "cygwin" || "$OSTYPE" == "msys" || "$OSTYPE" == "win32" ]]; then
            if ! powershell -Command "[System.Windows.Forms.MessageBox]::Show('$message', '$title')"; then
                log_message "ERROR" "Failed to send notification on Windows." "$LINENO"
            fi
        else
            log_message "ERROR" "Desktop notifications are only supported on macOS, Linux, and Windows." "$LINENO"
        fi
    fi
}

# Function: Send Pushover notifications
send_pushover_notification() {
    local title=$1
    local message=$2
    local website_url=$3
    local response

    if [ "$PUSHOVER_NOTIFICATION" = true ]; then
        log_message "DEBUG" "Processing Pushover notification: $website_url" "$LINENO"
        log_message "DEBUG" "Url: $website_url" "$LINENO"
        log_message "DEBUG" "Message: $message" "$LINENO"

        # Check if PUSHOVER_API_TOKEN is set
        if [[ -z "$PUSHOVER_API_TOKEN" ]]; then
            log_message "ERROR" "Error: PUSHOVER_API_TOKEN is not set." "$LINENO"
            return 1
        fi

        # Check if USER_KEY is set
        if [[ -z "$PUSHOVER_USER_KEY" ]]; then
            log_message "ERROR" "Error: PUSHOVER_USER_KEY is not set." "$LINENO"
            return 1
        fi

        # Build the curl command
        local curl_command="curl -s \
            --form-string \"token=$PUSHOVER_API_TOKEN\" \
            --form-string \"user=$PUSHOVER_USER_KEY\" \
            --form-string \"title=$title\" \
            --form-string \"message=$message\" \
            --form \"priority=0\" \
            https://api.pushover.net/1/messages.json"

        # Add URL options if website_url is defined
        if [[ -n "$website_url" ]]; then
            curl_command+=" --form \"url=$website_url\" --form \"url_title=Visit Site\""
        fi

        # Execute the curl command
        response=$(eval $curl_command)

        if [[ $? -ne 0 || -z "$response" ]]; then
            log_message "ERROR" "Failed to send Pushover notification for: $website_url" "$LINENO"
            return 1
        fi

        # Extract the status from the JSON response
        local status=$(echo "$response" | grep -o '"status":[0-9]*' | sed 's/"status"://')

        # Check if status is 1 (success)
        if [[ "$status" != "1" ]]; then
            log_message "ERROR" "Pushover API returned an error: $response" "$LINENO"
            return 1
        fi

        log_message "DEBUG" "Pushover notification sent successfully." "$LINENO"
        return 0
    fi
}

# ==============================
# Process Execution Functions
# ==============================

# Function: Start the service
start_service() {
    # Set up the trap for cleanup on app exit
    trap 'cleanup_pid' EXIT

    log_message "INFO" "Starting $APP_NAME service..." "$LINENO"

    # Launch the service as a background process in a subshell
    (
        main >/dev/null 2>&1 &
        local service_pid=$!

        # Sleep briefly to ensure the background process has initialized
        sleep 3

        # Verify that the background process is running by checking the PID
        if kill -0 "$service_pid" >/dev/null 2>&1; then
            IS_SERVICE=true
            # Write the PID to the file
            echo "$service_pid" >"$PID_FILE"
            log_message "DEBUG" "$APP_NAME service started with PID $service_pid." "$LINENO"
        else
            # If the process failed to start, clean up and exit
            log_message "FATAL" "Failed to start $APP_NAME service. PID is not valid." "$LINENO"
            cleanup_pid
            exit 1
        fi
    ) &

    # The service is now running in the background
    log_message "INFO" "$APP_NAME service is running in the background." "$LINENO"
}

# Function: Stop the service
stop_service() {
    if [[ ! -f "$PID_FILE" ]]; then
        log_message "INFO" "No $APP_NAME service is currently running." "$LINENO"
        exit 0
    fi

    local pid
    pid=$(cat "$PID_FILE")
    if kill -0 "$pid" >/dev/null 2>&1; then
        log_message "INFO" "Stopping $APP_NAME service with PID $pid..." "$LINENO"
        kill "$pid"
        cleanup_pid
        log_message "INFO" "$APP_NAME service stopped." "$LINENO"
    else
        log_message "WARN" "No active $APP_NAME process found for PID $pid. Cleaning up stale PID file." "$LINENO"
        cleanup_pid
    fi
}

# Function: Restart the service
restart_service() {
    if [[ ! -f "$PID_FILE" ]]; then
        log_message "INFO" "No $APP_NAME service is currently running." "$LINENO"
        exit 0
    fi

    log_message "INFO" "Restarting $APP_NAME service with PID $pid..." "$LINENO"
    stop_service
    start_service
}

# Function: Check the status of the service
status_service() {
    if [[ -f "$PID_FILE" ]]; then
        local pid
        pid=$(cat "$PID_FILE")
        if kill -0 "$pid" >/dev/null 2>&1; then
            log_message "INFO" "$APP_NAME service is running with PID $pid." "$LINENO"
        else
            log_message "WARN" "$APP_NAME service is not running, but PID file exists. Cleaning up stale PID file." "$LINENO"
            cleanup_pid
        fi
    else
        log_message "INFO" "$APP_NAME service is not running." "$LINENO"
    fi
}

# Function: Prevent running multiple interactive instances (except for specific cases)
check_already_running() {
    if [[ -f "$PID_FILE" ]]; then
        local pid
        pid=$(cat "$PID_FILE")
        if kill -0 "$pid" >/dev/null 2>&1; then
            log_message "ERROR" "Another instance of the $APP_NAME is already running (PID: $pid)." "$LINENO"
            exit 1
        else
            log_message "WARN" "Stale $APP_NAME PID file found. Cleaning up." "$LINENO"
            rm -f "$PID_FILE"
        fi
    fi
}

# Function: Cleanup PID file on exit
cleanup_pid() {
    # Ensure the PID file exists before attempting to clean it up
    if [[ -f "$PID_FILE" ]]; then
        log_message "DEBUG" "Cleaning up $APP_NAME PID file and exiting." "$LINENO"
        rm -f "$PID_FILE"
    fi
}

# Function: Run the check
start_process() {
    # Handle status or stop service before checking for running instances
    if [[ "$SHOW_STATUS" == true ]]; then
        status_service
        exit 0
    fi

    if [[ "$STOP_SERVICE" == true ]]; then
        stop_service
        exit 0
    fi

    # Check if an instance is already running
    if [[ "$RESTART_SERVICE" == true ]]; then
        restart_service
    else
        check_already_running

        # Log and start the configuration
        log_message "INFO" "Starting $APP_NAME: $(date)" "$LINENO"
        show_config

        # Start the service or run interactively
        if [[ "$START_SERVICE" == true ]]; then
            start_service
        else
            log_message "INFO" "Running $APP_NAME interactively..." "$LINENO"
            # Set up a trap for cleanup on termination
            trap 'cleanup_pid' EXIT
            echo $$ >"$PID_FILE"
            main
        fi
    fi
}

# ==============================
# Configuration and Initialization Functions
# ==============================

# Function: Load configuration from JSON file
load_config() {
    local config_file_path="$1"

    if key_exists "CONFIG_FILE" SKIP_CONFIG_KEYS[@] && [[ ! -f "$config_file_path" ]]; then
        log_message "FATAL" "Configuration file not found: $config_file_path" "$LINENO"
        exit 1
    elif ! key_exists "CONFIG_FILE" SKIP_CONFIG_KEYS[@] && [[ ! -f "$config_file_path" ]]; then
        return 0
    fi

    # Use jq to parse the JSON and set environment variables
    local jq_output
    jq_output=$(jq -r '.configuration | to_entries | .[] | "\(.key)=\(.value)"' "$config_file_path")
    log_message "DEBUG" "Configuration file settings: $jq_output" "$LINENO"

    while IFS="=" read -r key value; do
        # Skip empty lines, invalid entries, or keys that are in the skip_keys array
        if [[ -n "$key" && -n "$value" && ! " ${SKIP_CONFIG_KEYS[@]} " =~ " ${key} " && "$key" != "CONFIG_FILE" ]]; then
            [[ "$key" == *_DIR || "$key" == *_FILE || "$key" == *_CMD ]] && value="$(normalize_path "$value")"
            export "$key"="$value"
            log_message "DEBUG" "Setting $key=$value" "$LINENO"
        fi
    done <<<"$jq_output"
}

# Function: Get all "connections" groups and return them in an array
get_connection_groups() {
    local config_file_path="$1"
    jq -r '.connections | keys | sort[]' "$config_file_path"
}

# Function: Check if a key exists in the SKIP_CONFIG_KEYS
key_exists() {
    local key="$1"

    if [[ " ${SKIP_CONFIG_KEYS[@]} " =~ " ${key} " ]]; then
        return 0 # Key exists
    fi

    return 1 # Key does not exist
}

# Function: Get connection settings as key-value pairs
get_connection_settings() {
    local group="$1"
    local index="$2"
    local config_file_path="$3"
    local -n result_array=$4

    while IFS="=" read -r key value; do
        result_array["$key"]="$value"
        log_message "DEBUG" "Connection settings: $key=$value" "$LINENO"
    done < <(jq -r ".connections[\"$group\"][$index] | to_entries | map(\"\\(.key)=\\(.value)\") | .[]" "$config_file_path")
}

# Function: Show configuration file
show_config_file() {
    log_message "INFO" "Configuration file: $CONFIG_FILE" "$LINENO"
    log_message "INFO" "" "$LINENO"
    if [ -f "$CONFIG_FILE" ]; then
        cat "$CONFIG_FILE"
    else
        log_message "ERROR" "Configuration file not found: $CONFIG_FILE" "$LINENO"
    fi
    log_message "INFO" "" "$LINENO"
    exit 0
}

# Function: Initialize the configuration file
init_config() {
    # Ensure the directory for the configuration file exists
    config_dir=$(dirname "$CONFIG_FILE")
    if [ ! -d "$config_dir" ]; then
        printf "Configuration file directory %s does not exist. Creating it...\n" "$config_dir"
        mkdir -p "$config_dir" || {
            log_message "FATAL" "Failed to create directory: $config_dir" "$LINENO"
            exit 1
        }
    fi

    # Check if the configuration file already exists
    if [ -f "$CONFIG_FILE" ]; then
        if [ "$INIT_FORCE" = true ]; then
            printf "FORCE is true. Replacing the existing configuration file...\n"
        else
            read -p "Configuration file $CONFIG_FILE already exists. Do you want to replace it? (y/n): " choice
            case "$choice" in
            y | Y)
                printf "Replacing the existing configuration file...\n"
                ;;
            n | N)
                printf "Keeping the existing configuration file.\n"
                return
                ;;
            *)
                printf "Invalid choice. Keeping the existing configuration file.\n"
                return
                ;;
            esac
        fi
    fi

    # Create the configuration content
    config_content=$(
        cat <<EOF
{
    "configuration": {
        "CACHE_DIR": "$CACHE_DIR",
        "LOG_FILE": "$LOG_FILE",
        "CHECK_INTERVAL": "$CHECK_INTERVAL",
        "TIMEOUT": "$TIMEOUT",
        "SYSTEM_NAME": "$SYSTEM_NAME",
        "PUSHOVER_NOTIFICATION": "$PUSHOVER_NOTIFICATION",
        "PUSHOVER_USER_KEY": "$PUSHOVER_USER_KEY",
        "PUSHOVER_API_TOKEN": "$PUSHOVER_API_TOKEN",
        "DESKTOP_NOTIFICATION": "$DESKTOP_NOTIFICATION",
        "VERBOSE": "$VERBOSE",
        "LOG_LEVEL": "$LOG_LEVEL",
        "PING_TARGET": "$PING_TARGET",
        "DNS_TEST_DOMAIN": "$DNS_TEST_DOMAIN"
	}
}
EOF
    )

    # Write the configuration content to the file
    if ! echo "$config_content" >"$CONFIG_FILE"; then
        log_message "FATAL" "Failed to create configuration file at $CONFIG_FILE" "$LINENO"
        exit 1
    fi

    log_message "INFO" "Default configuration file created at $CONFIG_FILE" "$LINENO"
    exit 0
}

# Function: Show configuration information
show_config() {
    log_message "INFO" "Configuration file: $CONFIG_FILE" "$LINENO"
    log_message "INFO" "Cache directory: $CACHE_DIR" "$LINENO"
    log_message "INFO" "Log file: $LOG_FILE" "$LINENO"
    log_message "INFO" "PID file: $PID_FILE" "$LINENO"
    log_message "INFO" "Log Level: $LOG_LEVEL" "$LINENO"
    log_message "INFO" "Verbose enabled: $VERBOSE" "$LINENO"
    log_message "INFO" "System Name: $SYSTEM_NAME" "$LINENO"
    log_message "INFO" "Pushover enabled: $PUSHOVER_NOTIFICATION" "$LINENO"
    log_message "INFO" "Desktop notification enabled: $DESKTOP_NOTIFICATION" "$LINENO"
    log_message "INFO" "Check interval: $CHECK_INTERVAL" "$LINENO"
    log_message "INFO" "Timeout interval: $TIMEOUT" "$LINENO"
    log_message "INFO" "Repeat times: ${REPEAT:-0}" "$LINENO"
    log_message "INFO" "Ping target: $PING_TARGET" "$LINENO"
    log_message "INFO" "Test domain target: $DNS_TEST_DOMAIN" "$LINENO"
}

# ==============================
# Help Functions
# ==============================

# Function: Show help message
show_help() {
    printf "Usage: %s [options]\n" "$(basename "$0")"

    # General Options
    printf "\nGeneral Options:\n"
    printf "  -h, --help                  Display this help message.\n"
    printf "  -V, --version               Display the application version.\n"

    # Configuration and Initialization
    printf "\nConfiguration and Initialization:\n"
    printf "  -c, --config <config_file>  Specify a custom configuration file (default: %s).\n" "${CONFIG_FILE}"
    printf "  -i, --init                  Initialize the configuration file.\n"
    printf "  -f, --force-init            Force initialize of the configuration file if one exists.\n"
    printf "  -S, --show-config           Show the configuration settings.\n"
    printf "  -e, --show-config-file      Show the configuration file.\n"
    printf "  -E, --edit-config           Edit the configuration file.\n"

    # Cache Management
    printf "\nCache Management:\n"
    printf "  -x, --clean                 Delete all cached files.\n"
    printf "  -C, --cache-dir  <path>     Specify a custom cache directory (default: %s).\n" "${CACHE_DIR}"

    # Notification Options
    printf "\nNotification Options:\n"
    printf "  -n, --system-name           Name of the system running the script (default: %s).\n" "${SYSTEM_NAME}"
    printf "  -p, --pushover              Send Pushover notifications.\n"
    printf "  -u, --user-key <key>        Specify the user key for Pushover notifications.\n"
    printf "  -a, --api-token <token>     Specify the API token for Pushover notifications.\n"
    printf "  -d, --desktop               Send desktop notifications using AppleScript.\n"

    # Logging and Output
    printf "\nLogging and Output:\n"
    printf "  -v, --verbose               Enable verbose output.\n"
    printf "  -l, --log                   Log the log file to the screen.\n"
    printf "  -o, --output <file>         Specify a custom log file location (default: %s).\n" "${LOG_FILE}"
    printf "  -L, --log-level <level>     Set the log level (FATAL, ERROR, WARN, INFO, DEBUG).\n"

    # Remote Connection Configuration
    printf "\nRemote Connection Configuration:\n"
    printf "  -I, --interval <s,m,h,d>    Set the interval between checks (default: %s).\n" "${CHECK_INTERVAL}"
    printf "  -T, --timeout <s,m,h,d>     Set the connection timeout for remote connections (default: %s).\n" "${TIMEOUT}"
    printf "  -N, --repeat <number>       Repeat the checks in interactive mode N number of times and exit (default: %s).\n" "${REPEAT:-0}"
    printf "  -P, --ping-target <IP>      Set a custom ping target (default: %s).\n" "${PING_TARGET}"
    printf "  -D, --dns-test-domain <domain>  Set a custom DNS test domain (default: %s).\n" "${DNS_TEST_DOMAIN}"

    # Process Management Functions
    printf "\nProcess Management:\n"
    printf "  -s, --start                 Start the %s service in the background.\n" "${APP_NAME}"
    printf "  -k, --stop                  Stop the %s service.\n" "${APP_NAME}"
    printf "  -r, --restart               Restart the %s service.\n" "${APP_NAME}"
    printf "  -t, --status                Check the current status of the %s service.\n" "${APP_NAME}"

    # Examples
    printf "\nExamples:\n"
    printf "  Run interactively with default settings:\n"
    printf "    %s\n" "$(basename "$0")"
    printf "\n"
    printf "  Run interactively with custom targets:\n"
    printf "    %s --ping-target 1.1.1.1 --dns-test-domain google.com\n" "$(basename "$0")"
    printf "\n"
    printf "  Start the service with default settings:\n"
    printf "    %s --start\n" "$(basename "$0")"
    printf "\n"
    printf "  Start the service with custom targets:\n"
    printf "    %s --ping-target 1.1.1.1 --dns-test-domain google.com --start\n" "$(basename "$0")"
    printf "\n"
    printf "  Check service status:\n"
    printf "    %s --status\n" "$(basename "$0")"
    printf "\n"
    printf "  Stop the service:\n"
    printf "    %s --stop\n" "$(basename "$0")"
    printf "\n"
}

# ==============================
# Argument Processing Functions
# ==============================

# Function: Parse command-line arguments and setup environment
parse_cli_options() {

    # Default configuration file locations
    CONFIG_FILE="$(get_config_path "$CONFIG_FILE_NAME")"
    CACHE_DIR="$(get_temp_path "$CACHE_DIR")"
    LOG_FILE="$(normalize_path "$CACHE_DIR/$LOG_FILE_NAME")"

    # Set default hostname
    SYSTEM_NAME="$(get_hostname)"

    # Process high priority items first
    [[ " $@ " =~ " --help " || " $@ " =~ " -h " ]] && show_help && show_version && exit 0
    [[ " $@ " =~ " --version " || " $@ " =~ " -V " ]] && show_version && exit 0

    # Check for log level and verbose and process so they are available early
    if [[ " $@ " =~ " --log-level " || " $@ " =~ " -L " ]]; then
        for ((i = 1; i <= $#; i++)); do
            case "${!i}" in
            --log-level | -L)
                next=$((i + 1))
                if [[ -z "${!next}" || "${!next}" == -* ]]; then
                    printf "Error: %s requires a value\n" "${!i}" >&2
                    exit 1
                fi
                # Check if the log level exists in the LOG_LEVELS_MAP array
                if [[ -n "${LOG_LEVELS_MAP[${!next}]}" ]]; then
                    LOG_LEVEL="${!next}"
                    SKIP_CONFIG_KEYS+=("LOG_LEVEL")
                else
                    printf "Error: %s requires a valid value. Available levels are: %s\n" "${!i}" "${!LOG_LEVELS_MAP[*]}" >&2
                    exit 1
                fi
                # Remove the processed options from the arguments list
                set -- "${@:1:$((i - 1))}" "${@:((i + 2))}"
                i=$((i - 1))
                ;;
            --verbose | -v)
                VERBOSE=true
                SKIP_CONFIG_KEYS+=("VERBOSE")
                # Remove the processed options from the arguments list
                set -- "${@:1:$((i - 1))}" "${@:((i + 1))}"
                i=$((i - 1))
                ;;
            esac
        done
    fi

    # Process remaining options
    local options_processed=false
    while [[ $# -gt 0 ]]; do
        case "$1" in
        # Configuration and Initialization
        --config | -c)
            if [[ -z "$2" || "$2" == -* ]]; then
                printf "Error: %s requires a value\n" "$1" >&2
                exit 1
            fi
            CONFIG_FILE="$(normalize_path "$2")"
            SKIP_CONFIG_KEYS+=("CONFIG_FILE")
            shift 2
            ;;
        --init | -i)
            INIT=true
            shift
            ;;
        --force-init | -f)
            INIT_FORCE=true
            shift
            ;;
        --show-config | -S)
            SHOW_CONFIG=true
            shift
            ;;
        --show-config-file | -e)
            SHOW_CONFIG_FILE=true
            shift
            ;;
        --edit-config | -E)
            EDIT_CONFIG_FILE=true
            shift
            ;;

        # Cache Management
        --clean | -x)
            CLEAN=true
            shift
            ;;
        --cache-dir | -C)
            if [[ -z "$2" || "$2" == -* ]]; then
                printf "Error: %s requires a value\n" "$1" >&2
                exit 1
            fi
            CACHE_DIR="$(normalize_path "$2")"
            LOG_FILE="$(normalize_path "$2/$LOG_FILE_NAME")"
            SKIP_CONFIG_KEYS+=("CACHE_DIR")
            shift 2
            ;;

        # Notification Options
        --system-name | -n)
            if [[ -z "$2" || "$2" == -* ]]; then
                printf "Error: %s requires a value\n" "$1" >&2
                exit 1
            fi
            SYSTEM_NAME="$2"
            SKIP_CONFIG_KEYS+=("SYSTEM_NAME")
            shift 2
            ;;
        --pushover | -p)
            PUSHOVER_NOTIFICATION=true
            SKIP_CONFIG_KEYS+=("PUSHOVER_NOTIFICATION")
            shift
            ;;
        --user-key | -u)
            if [[ -z "$2" || "$2" == -* ]]; then
                printf "Error: %s requires a value\n" "$1" >&2
                exit 1
            fi
            PUSHOVER_USER_KEY="$2"
            SKIP_CONFIG_KEYS+=("PUSHOVER_USER_KEY")
            shift 2
            ;;
        --api-token | -a)
            if [[ -z "$2" || "$2" == -* ]]; then
                printf "Error: %s requires a value\n" "$1" >&2
                exit 1
            fi
            PUSHOVER_API_TOKEN="$2"
            SKIP_CONFIG_KEYS+=("PUSHOVER_API_TOKEN")
            shift 2
            ;;
        --desktop | -d)
            DESKTOP_NOTIFICATION=true
            SKIP_CONFIG_KEYS+=("DESKTOP_NOTIFICATION")
            shift
            ;;

        # Logging and Output
        --log | -l)
            SHOW_LOG=true
            shift
            ;;
        --output | -o)
            if [[ -z "$2" || "$2" == -* ]]; then
                printf "Error: %s requires a value\n" "$1" >&2
                exit 1
            fi
            LOG_FILE="$(normalize_path "$2")"
            SKIP_CONFIG_KEYS+=("LOG_FILE")
            shift 2
            ;;

        # Remote Connection Configuration
        --interval | -I)
            if [[ -z "$2" || "$2" == -* ]]; then
                printf "Error: %s requires a value\n" "$1" >&2
                exit 1
            fi
            CHECK_INTERVAL="$2"
            SKIP_CONFIG_KEYS+=("CHECK_INTERVAL")
            shift 2
            ;;
        --timeout | -T)
            if [[ -z "$2" || "$2" == -* ]]; then
                printf "Error: %s requires a value\n" "$1" >&2
                exit 1
            fi
            TIMEOUT="$2"
            SKIP_CONFIG_KEYS+=("TIMEOUT")
            shift 2
            ;;
        --repeat | -N)
            if [[ -z "$2" || "$2" == -* ]]; then
                printf "Error: %s requires a value\n" "$1" >&2
                exit 1
            fi
            if ! [[ "$2" =~ ^[0-9]+$ ]]; then
                printf "Error: Timeout must be an integer\n" >&2
                exit 1
            fi
            REPEAT="$2"
            SKIP_CONFIG_KEYS+=("REPEAT")
            shift 2
            ;;
        --ping-target | -P)
            if [[ -z "$2" || "$2" == -* ]]; then
                printf "Error: %s requires a value\n" "$1" >&2
                exit 1
            fi
            PING_TARGET="$2"
            SKIP_CONFIG_KEYS+=("PING_TARGET")
            shift 2
            ;;
        --dns-test-domain | -D)
            if [[ -z "$2" || "$2" == -* ]]; then
                printf "Error: %s requires a value\n" "$1" >&2
                exit 1
            fi
            DNS_TEST_DOMAIN="$2"
            SKIP_CONFIG_KEYS+=("DNS_TEST_DOMAIN")
            shift 2
            ;;

        # Process Management
        --start | -s)
            START_SERVICE=true
            shift
            ;;
        --stop | -k)
            STOP_SERVICE=true
            shift
            ;;
        --restart | -r)
            RESTART_SERVICE=true
            shift
            ;;
        --status | -t)
            SHOW_STATUS=true
            shift
            ;;

        # End of Options
        --)
            options_processed=true
            shift
            break
            ;;

        # All remaining input is invalid
        -*)
            printf "Error: Unknown option: %s\n" "$1" >&2
            exit 1
            ;;
        *)
            printf "Error: Invalid input: %s\n" "$1" >&2
            exit 1
            ;;
        esac
    done

    # Check for cache critical path
    if is_critical_directory "$CACHE_DIR"; then
        log_message "FATAL" "Attempted to set cache path to a critical directory '$CACHE_DIR'. Aborting." "$LINENO"
        exit 1
    fi

    # Delete the cache directory and exit
    [[ "$CLEAN" = true ]] && delete_cache

    # Initialize the default configuration file and exit
    [[ -z "$INIT" || "$INIT" = false ]] && load_config "$CONFIG_FILE"
    [[ "$INIT" = true ]] && init_config
    init_cache
    init_log

    # Set the PID file based on final CACHE_DIR
    PID_FILE="$(normalize_path "$CACHE_DIR/$PID_FILE_NAME")"

    # Process final commands after configuration is completely finalized
    [[ "$EDIT_CONFIG_FILE" = true ]] && edit_file "$CONFIG_FILE"
    [[ "$SHOW_LOG" = true ]] && show_log
    [[ "$SHOW_CONFIG_FILE" = true ]] && show_config_file

    # Run a final processing of arguments
    process_arguments
}

# Function: Process and execute actions based on parsed arguments
process_arguments() {
    # App specific configuration and parsing
    NETWORK_CSV_FILE="$CACHE_DIR/$NETWORK_CSV_FILE"
    DNS_CSV_FILE="$CACHE_DIR/$DNS_CSV_FILE"

    # Initialize CSV file
    init_csv

    # Keep this last so we show the final configuration state
    [[ "$SHOW_CONFIG" = true ]] && show_config && show_version && exit
}

# ==============================
# Application Functions
# ==============================

# Function: Initialize the CSV downtime history files
init_csv() {
    # Initialize CSV files with headers if they don't exist
    if [[ ! -f "$NETWORK_CSV_FILE" ]]; then
        echo "Down,Up,Duration" >"$NETWORK_CSV_FILE"
        log_message "DEBUG" "Created Network Down history file: $NETWORK_CSV_FILE" "$LINENO"
    fi
    if [[ ! -f "$DNS_CSV_FILE" ]]; then
        echo "Down,Up,Duration" >"$DNS_CSV_FILE"
        log_message "DEBUG" "Created DNS Down history file: $DNS_CSV_FILE" "$LINENO"
    fi
}

# ==============================
# Main Application Execution
# ==============================

# Function: Start the main process
main() {
    local repeat_count=0
    local interval=$(get_interval_in_seconds "$CHECK_INTERVAL")
    local timeout=$(get_interval_in_seconds "$TIMEOUT")
    local network_down_start dns_down_start
    local network_down=false dns_down=false

    while true; do
        # Cross-platform timestamp handling
        local current_time=$(date +%s) # Unix timestamp for calculations
        local current_timestamp
        if [[ "$OSTYPE" == "darwin"* ]]; then
            current_timestamp=$(date -u "+%Y-%m-%dT%H:%M:%SZ")
        else
            current_timestamp=$(date -u "+%Y-%m-%dT%H:%M:%SZ")
        fi

        log_message "DEBUG" "Current timestamp: $current_timestamp" "$LINENO"

        # Start of main application function calls

        # Check network connectivity
        if ping -c 1 -W "$timeout" "$PING_TARGET" >/dev/null 2>&1; then
            log_message "DEBUG" "Network is up" "$LINENO"
            # Network is up
            if [[ "$network_down" = true ]]; then
                # Calculate total network downtime
                local network_up_timestamp="$current_timestamp"
                local network_down_duration=$((current_time - network_down_start))
                if [[ "$OSTYPE" == "darwin"* ]]; then
                    echo "$(date -u -r "$network_down_start" "+%Y-%m-%dT%H:%M:%SZ"),$network_up_timestamp,$network_down_duration" >>"$NETWORK_CSV_FILE"
                else
                    echo "$(date -u -d "@$network_down_start" "+%Y-%m-%dT%H:%M:%SZ"),$network_up_timestamp,$network_down_duration" >>"$NETWORK_CSV_FILE"
                fi
                local message="$network_up_timestamp: $SYSTEM_NAME network is back online after $network_down_duration seconds of downtime."
                log_message "WARN" "$message" "$LINENO"
                send_desktop_notification "$APP_NAME Alert" "$message"
                send_pushover_notification "$APP_NAME Alert" "$message"
                network_down=false
            fi

            # Check DNS resolution
            if nslookup -timeout="$timeout" -retry=1 "$DNS_TEST_DOMAIN" >/dev/null 2>&1; then
                log_message "DEBUG" "$SYSTEM_NAME DNS resolution is successful" "$LINENO"
                # DNS is up
                if [[ "$dns_down" = true ]]; then
                    # Calculate total DNS downtime
                    local dns_up_timestamp="$current_timestamp"
                    local dns_down_duration=$((current_time - dns_down_start))
                    if [[ "$OSTYPE" == "darwin"* ]]; then
                        echo "$(date -u -r "$dns_down_start" "+%Y-%m-%dT%H:%M:%SZ"),$dns_up_timestamp,$dns_down_duration" >>"$DNS_CSV_FILE"
                    else
                        echo "$(date -u -d "@$dns_down_start" "+%Y-%m-%dT%H:%M:%SZ"),$dns_up_timestamp,$dns_down_duration" >>"$DNS_CSV_FILE"
                    fi
                    local message="$dns_up_timestamp: $SYSTEM_NAME DNS resolution is back after $dns_down_duration seconds of downtime."
                    log_message "WARN" "$message" "$LINENO"
                    send_desktop_notification "$APP_NAME Alert" "$message"
                    send_pushover_notification "$APP_NAME Alert" "$message"
                    dns_down=false
                fi
            else
                log_message "DEBUG" "$SYSTEM_NAME DNS resolution failed" "$LINENO"
                # DNS is down
                if [[ "$dns_down" = false ]]; then
                    dns_down_start=$current_time
                    local message="$current_timestamp: $SYSTEM_NAME DNS resolution failed. DNS is now down."
                    log_message "ERROR" "$message" "$LINENO"
                    send_desktop_notification "$APP_NAME Alert" "$message"
                    dns_down=true
                fi
            fi
        else
            log_message "DEBUG" "$SYSTEM_NAME network is down" "$LINENO"
            # Network is down
            if [[ "$network_down" = false ]]; then
                network_down_start=$current_time
                local message="$current_timestamp: $SYSTEM_NAME network is down."
                log_message "ERROR" "$message" "$LINENO"
                send_desktop_notification "$APP_NAME Alert" "$message"
                network_down=true
            fi
        fi

        # End of main application function calls

        # Increment the repeat counter
        repeat_count=$((repeat_count + 1))
        log_message "DEBUG" "Iteration: $repeat_count" "$LINENO"

        # Check if REPEAT is set and not zero
        if [[ -z "$REPEAT" || "$REPEAT" != 0 ]] && [[ "$repeat_count" -ge "$REPEAT" ]]; then
            log_message "DEBUG" "Reached the maximum number of repetitions: $REPEAT" "$LINENO"
            break
        else
            log_message "DEBUG" "Sleeping for $CHECK_INTERVAL" "$LINENO"
            sleep "$interval"
        fi
    done
}

# Call the function to check for required dependencies
check_dependencies

# Call the function to parse cli options
parse_cli_options "$@"

# Call the main function to start the process
start_process
